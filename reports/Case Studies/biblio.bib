
@inproceedings{janishidi_system_2008,
	title = {System of {Systems} - {Innovations} for 21st {Century}},
	booktitle = {Proceedings of the {IEEE} {Region} 10 and the {Third} international {Conference} on {Industrial} and {Information} {Systems}, 2008. {ICIIS} 2008},
	author = {Janishidi, M.},
	year = {2008},
	pages = {6--7},
}

@inproceedings{jansen_sense_2009,
	title = {A sense of community: {A} research agenda for software ecosystems},
	isbn = {978-1-4244-3495-4},
	booktitle = {Proceedings of the 31st {International} {Conference} on {Software} {Engineering} - {Companion} {Volume}, 2009. {ICSE}-{Companion} 2009},
	author = {Jansen, S. and Finkelstein, A. and Brinkkemper, S.},
	year = {2009},
	pages = {187--190},
}


@inproceedings{dig_role_2005,
	title = {The {Role} of {Refactorings} in {API} {Evolution}},
	isbn = {978-0-7695-2368-2},
	booktitle = {Proceedings of the 21st {IEEE} {International} {Conference} on {Software} {Maintenance}},
	author = {Dig, Danny and Johnson, Ralph},
	year = {2005},
	pages = {389--398}
}

@inproceedings{robbes_how_2012,
	address = {New York, NY, USA},
	series = {{FSE} '12},
	title = {How {Do} {Developers} {React} to {API} {Deprecation}?: {The} {Case} of a {Smalltalk} {Ecosystem}},
	isbn = {978-1-4503-1614-9},
	shorttitle = {How {Do} {Developers} {React} to {API} {Deprecation}?},
	url = {http://doi.acm.org/10.1145/2393596.2393662},
	doi = {10.1145/2393596.2393662},
	abstract = {When the Application Programming Interface (API) of a framework or library changes, its clients must be adapted. This change propagation---known as a ripple effect---is a problem that has garnered interest: several approaches have been proposed in the literature to react to these changes. Although studies of ripple effects exist at the single system level, no study has been performed on the actual extent and impact of these API changes in practice, on an entire software ecosystem associated with a community of developers. This paper reports on an empirical study of API deprecations that led to ripple effects across an entire ecosystem. Our case study subject is the development community gravitating around the Squeak and Pharo software ecosystems: seven years of evolution, more than 3,000 contributors, and more than 2,600 distinct systems. We analyzed 577 methods and 186 classes that were deprecated, and answer research questions regarding the frequency, magnitude, duration, adaptation, and consistency of the ripple effects triggered by API changes.},
	urldate = {2015-12-16},
	booktitle = {Proceedings of the {ACM} {SIGSOFT} 20th {International} {Symposium} on the {Foundations} of {Software} {Engineering}},
	publisher = {ACM},
	author = {Robbes, Romain and Lungu, Mircea and RÃ¶thlisberger, David},
	year = {2012},
	keywords = {Ecosystems, Empirical Studies, Mining Software Repositories},
	pages = {56:1--56:11},
}


@inproceedings{kim_empirical_2011,
	address = {New York, NY, USA},
	series = {{ICSE} '11},
	title = {An {Empirical} {Investigation} into the {Role} of {API}-level {Refactorings} {During} {Software} {Evolution}},
	isbn = {978-1-4503-0445-0},
	url = {http://doi.acm.org/10.1145/1985793.1985815},
	doi = {10.1145/1985793.1985815},
	abstract = {It is widely believed that refactoring improves software quality and programmer productivity by making it easier to maintain and understand software systems. However, the role of refactorings has not been systematically investigated using fine-grained evolution history. We quantitatively and qualitatively studied API-level refactorings and bug fixes in three large open source projects, totaling 26523 revisions of evolution. The study found several surprising results: One, there is an increase in the number of bug fixes after API-level refactorings. Two, the time taken to fix bugs is shorter after API-level refactorings than before. Three, a large number of refactoring revisions include bug fixes at the same time or are related to later bug fix revisions. Four, API-level refactorings occur more frequently before than after major software releases. These results call for re-thinking refactoring's true benefits. Furthermore, frequent floss refactoring mistakes observed in this study call for new software engineering tools to support safe application of refactoring and behavior modifying edits together.},
	urldate = {2015-12-16},
	booktitle = {Proceedings of the 33rd {International} {Conference} on {Software} {Engineering}},
	publisher = {ACM},
	author = {Kim, Miryung and Cai, Dongxiang and Kim, Sunghun},
	year = {2011},
	keywords = {defects, empirical study, refactoring, release cycle, software evolution},
	pages = {151--160}
}


@inproceedings{bavota_evolution_2013,
	title = {The {Evolution} of {Project} {Inter}-dependencies in a {Software} {Ecosystem}: {The} {Case} of {Apache}},
	shorttitle = {The {Evolution} of {Project} {Inter}-dependencies in a {Software} {Ecosystem}},
	doi = {10.1109/ICSM.2013.39},
	abstract = {Software ecosystems consist of multiple software projects, often interrelated each other by means of dependency relations. When one project undergoes changes, other projects may decide to upgrade the dependency. For example, a project could use a new version of another project because the latter has been enhanced or subject to some bug-fixing activities. This paper reports an exploratory study aimed at observing the evolution of the Java subset of the Apache ecosystem, consisting of 147 projects, for a period of 14 years, and resulting in 1,964 releases. Specifically, we analyze (i) how dependencies change over time, (ii) whether a dependency upgrade is due to different kinds of factors, such as different kinds of API changes or licensing issues, and (iii) how an upgrade impacts on a related project. Results of this study help to comprehend the phenomenon of library/component upgrade, and provides the basis for a new family of recommenders aimed at supporting developers in the complex (and risky) activity of managing library/component upgrade within their software projects.},
	booktitle = {2013 29th {IEEE} {International} {Conference} on {Software} {Maintenance} ({ICSM})},
	author = {Bavota, G. and Canfora, G. and Di Penta, M. and Oliveto, R. and Panichella, S.},
	month = sep,
	year = {2013},
	keywords = {Apache ecosystem, API, data mining, Ecosystems, History, Java, Java subset, Libraries, Licenses, multiple software projects, project inter-dependencies, Software, software ecosystem, software engineering, software management},
	pages = {280--289},
}


@inproceedings{mcdonnell_empirical_2013,
	title = {An {Empirical} {Study} of {API} {Stability} and {Adoption} in the {Android} {Ecosystem}},
	doi = {10.1109/ICSM.2013.18},
	abstract = {When APIs evolve, clients make corresponding changes to their applications to utilize new or updated APIs. Despite the benefits of new or updated APIs, developers are often slow to adopt the new APIs. As a first step toward understanding the impact of API evolution on software ecosystems, we conduct an in-depth case study of the co-evolution behavior of Android API and dependent applications using the version history data found in github. Our study confirms that Android is evolving fast at a rate of 115 API updates per month on average. Client adoption, however, is not catching up with the pace of API evolution. About 28\% of API references in client applications are outdated with a median lagging time of 16 months. 22\% of outdated API usages eventually upgrade to use newer API versions, but the propagation time is about 14 months, much slower than the average API release interval (3 months). Fast evolving APIs are used more by clients than slow evolving APIs but the average time taken to adopt new versions is longer for fast evolving APIs. Further, API usage adaptation code is more defect prone than the one without API usage adaptation. This may indicate that developers avoid API instability.},
	booktitle = {2013 29th {IEEE} {International} {Conference} on {Software} {Maintenance} ({ICSM})},
	author = {McDonnell, T. and Ray, B. and Kim, Miryung},
	month = sep,
	year = {2013},
	keywords = {Android API coevolution behavior, Android ecosystem, Androids, API evolution, API stability, API usage adaptation code, application program interfaces, github, Google, History, Humanoid robots, Mobile communication, mobile computing, operating systems (computers), smart phones, Software, software ecosystems, software maintenance, version history data},
	pages = {70--79}
}